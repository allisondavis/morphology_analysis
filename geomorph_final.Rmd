---
title: "geomorph_final"
author: "Allison Davis Connelly"
date: "2025-02-01"
output: 
  html_document:
    toc: TRUE
    toc_depth: 5
    toc_float:
      collapsed: FALSE
  
      
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Purpose

There are two main goals of this analysis. First, we want to compare morphological variation among the asexual Amazon molly and their two parental species (sailfin and Atlantic molly) across their native and introduced geographic range [PART 1]. Second, we want to compare the precision between the two data collection methods used (manual measurements versus digital geomorphometrics) [PART 2]. 

# PART 1: variation analysis

The following analyses will compare variation among the species. 

## Data

Original TPS files were imported into MorphoJ (CITE?) where we performed a procrustes analysis and a multivariate regression on shape (procrustes coordinates) and size (centroid size) to correct for overall body size differences between the species. We then imported the residuals of this regression below to perform our analyses.

All analyses were conducted using R version 4.4.2


### Load required libraries

Remove the '#' in the code below if it is the first time installing library. 

```{r}

#install.packages("curl")             #v5.2.1
library(curl)

#install.packages("dplyr")            #v1.1.4
library(dplyr)

#install.packages("tidyverse")        #v2.0.0
library(tidyverse)

#install.packages("tidyr")            #v1.3.1
library(tidyr)

#install.packages("gt")               #v0.11.1
library(gt)

#install.packages("factoextra")       #v1.0.7
library(factoextra)

#install.packages("car")              #v3.1-2
library(car)

#install.packages("AMR")              #v2.1.1 DOUBLE CHECK I NEED ALL OF THE FOLLOWING 4
library(AMR)

#install.packages("ggplot2")          #v3.5.1
library(ggplot2)

#install.packages("ggfortify")        #v0.4.17
library(ggfortify)

#install.packages("ggbiplot")         #v0.6.2
library(ggbiplot)

#install.packages("gridExtra")        #v2.3
library(gridExtra)

#install.packages("blandr")           #v0.6.0
library(blandr)

#install.packages("stringr")          #v1.5.1
library(stringr)

```


### Read in data

```{r}

test.df <- curl("https://raw.githubusercontent.com/allisondavis/morphology_analysis/refs/heads/master/MV%20regression%2C%20results.txt")

test.df <- read.table(test.df, header = TRUE, sep = "\t")

# Replace HydroBASIN basin codes with basin names
test.df$Basin <- factor(test.df$Basin,
                        levels = c("7040048420", "7040049270", "7040048310", "7040049990", "7040049280"),
                        labels = c("Nueces-Rio Grande Costal", "Rio Grande", "Brazos-Colorado Costal", "Panuco", "San Fernando-Soto la Marina"))

# Replace default residual column names with the corresponding landmark (x,y). This will make it easier to interpret which size-corrected shape coordinates influence our results later on.

n_landmarks <- 16

coord_names <- as.vector(rbind(
  paste0("LM", 1:n_landmarks, ".X"),
  paste0("LM", 1:n_landmarks, ".Y")
))

colnames(test.df)[7:(6 + length(coord_names))] <- coord_names



```


## Analysis

### PCA

We'll create a PCA to visualize overall shape differences. We'll then perform Levene's tests on the PC scores to assess differences in variation among the species. 

#### Loadings MAKE SURE I NEED ALL OF THIS

```{r}

PCA.test <- prcomp(test.df[, 7:38], center = TRUE, scale. = FALSE) 
#NOTE: scale=false uses covariance matrix like in MorphoJ (what we imported); scale=true only useful if variables are measured on different scales

summary(PCA.test)
(eig.val.test <- get_eigenvalue(PCA.test))


# the first 3 dimensions account for over half of the variation. We will extract the individual scores for the first 3 dimensions and attach it to the original data frame.

ind.test <- get_pca_ind(PCA.test)
head(ind.test$coord[,1:3])


test.df <- cbind(test.df, ind.test$coord[,1:3])


# Will investigate the influence of each landmark coordinates on the first 3 dimensions
(loadings <- PCA.test$rotation[, 1:3])

sorted.loadings.1 <- loadings[order(loadings[, 1]), 1]
myTitle <- "Loadings Plot for PC1" 
myXlab  <- "Variable Loadings"
dotchart(sorted.loadings.1, main=myTitle, xlab=myXlab, cex=0.5, col="blue")

sorted.loadings.2 <- loadings[order(loadings[, 2]), 2]
myTitle <- "Loadings Plot for PC2" 
myXlab  <- "Variable Loadings"
dotchart(sorted.loadings.2, main=myTitle, xlab=myXlab, cex=0.5, col="blue")

sorted.loadings.3 <- loadings[order(loadings[, 3]), 3]
myTitle <- "Loadings Plot for PC3" 
myXlab  <- "Variable Loadings"
dotchart(sorted.loadings.3, main=myTitle, xlab=myXlab, cex=0.5, col="blue")

```

#### Post PCA tests

We perform a Levene's Test for each dimension to assess variation among the species. This will inform us if the spread of shape variation is different among the species. 

```{r}

pc1V <- leveneTest(Dim.1~Species, data=test.df) # not significant (p=0.708)

pc2V <- leveneTest(Dim.2~Species, data=test.df) # significant (p<0.001)

pc3V <- leveneTest(Dim.3~Species, data=test.df) # significant (p=0.01)


# Will display results in a table
levene_result <- tibble(
  Dimension = c("PC1", "PC2", "PC3"),
  F_value = c(pc1V$`F value`[1], pc2V$`F value`[1], pc3V$`F value`[1]),
  p_value = c(pc1V$`Pr(>F)`[1], pc2V$`Pr(>F)`[1], pc3V$`Pr(>F)`[1])
) %>%
  mutate(Significance = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01 ~ "**",
    p_value < 0.05 ~ "*",
    TRUE ~ "ns"
  ))

levene_result %>%
  gt() %>%
  cols_label(
    Dimension = "Dimension",
    F_value = "F-value",
    p_value = "p-value",
    Significance = "Significance") %>%
  fmt_number(columns = c("F_value"), decimals = 3) %>%
  fmt(columns = vars(p_value), fns = function(x) {  
    ifelse(x < 0.001, "p < 0.001", formatC(x, format = "f", digits = 3))
  }) 



# Summary of variation for each dimension in each species
  ## Sailfin mollies have highest amount of variation in PC1 and PC2 (followed by Atlantic and then Amazon); Amazon's have highest amount of variation in PC3 (followed by Atlantic then sailfins).

test.df %>%
  group_by(Species) %>%
  summarise(var_dim1=var(Dim.1, na.rm = TRUE),
            var_dim2=var(Dim.2, na.rm = TRUE),
            var_dim3=var(Dim.3, na.rm=TRUE)) %>%
  mutate(Species = case_when(
    Species == "p.latipinna" ~ "Sailfin molly",
    Species == "p.formosa" ~ "Amazon molly",
    Species == "p.mexicana" ~ "Atlantic molly")) %>%
  gt() %>% tab_header(title = "Variation of Dimensions 1-3") %>%
  cols_label(Species = "Species",
             var_dim1 = "Dimension 1",
             var_dim2 = "Dimension 2",
             var_dim3 = "Dimension 3") %>%
  fmt_scientific(columns = c("var_dim1", "var_dim2", "var_dim3"), decimals = 2) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)), 
    locations = cells_body(columns = c("Species", "var_dim1", "var_dim2")))



# pairwise comparisons for significant dimensions
  ## Only significant pairwise comparison (even after Holms correction) is between Amazon's and Sailfins for both PC2 and PC3


# will create a function to group all pairwise comparisons into one table

pairwise_variance_test <- function(df, pcs = c("PC1", "PC2"), group = "Species", adjust = "holm", digits = 5) {
  
  if (!group %in% names(df)) stop(paste("Grouping variable", group, "not found in data frame."))
  
  groups <- unique(df[[group]])
  
  all_results <- list()
  
  for (pc in pcs) {
    if (!pc %in% names(df)) {
      warning(paste("Column", pc, "not found in data-skipping."))
    }
  
    pairs <- combn(groups, 2, simplify = FALSE)
    
    res_list <- lapply(pairs, function(pair) {
      sp1 <- df[[pc]][df[[group]] == pair[1]]
      sp2 <- df[[pc]][df[[group]] == pair[2]]
      
      # Look for possible errors (e.g., too few values)
      test <- tryCatch(var.test(sp1, sp2), error = function(e) NULL)
      if (is.null(test)) return(NULL)
      
      data.frame(
        PC = pc,
        group1 = pair[1],
        group2 = pair[2],
        F.value = as.numeric(test$statistic),
        p.value = test$p.value
      )
    }) 
    
    pc_results <- do.call(rbind, res_list)
    all_results[[pc]] <- pc_results
    
    results <- do.call(rbind, all_results)
  }
  
  # P-value adjustment and formatting
  results$p.adjusted <- p.adjust(results$p.value, method = adjust)
  results$p.value <- round(results$p.value, digits)
  results$p.adjusted <- round(results$p.adjusted, digits)
  results$F.value <- round(results$F.value, digits)
  
  attr(results, "adjustment_method") <- adjust
  attr(results, "grouping_variable") <- group
  
  return(results)
}


# run test
(PW_results <- pairwise_variance_test(test.df, pcs = c("Dim.2", "Dim.3")))



# Results in a prettier table 
PW_results %>%
  arrange(PC, group1, group2) %>%
  group_by(PC) %>%
  mutate(
    group1 = dplyr::recode(group1, "p.latipinna" = "Sailfin", "p.formosa" = "Amazon", "p.mexicana" = "Atlantic"),
    group2 = dplyr::recode(group2, "p.latipinna" = "Sailfin", "p.formosa" = "Amazon", "p.mexicana" = "Atlantic"),
    PC = dplyr::recode(PC, "Dim.2" = "PC2", "Dim.3" = "PC3"),
    PC = if_else(row_number() == 2, PC, ""),
    significance = case_when(
      p.adjusted < 0.001 ~ "***",
      p.adjusted < 0.005 ~ "**",
      p.adjusted < 0.01 ~ "*",
      TRUE ~ "ns")) %>%
  ungroup() %>%
  gt() %>% 
  tab_header(title = "Pairwise Comparisons of Variation") %>%
  cols_label(PC = "PC",
             group1 = "Species A",
             group2 = "Species B",
             F.value = "F Statistic",
             p.value = "p-value",
             p.adjusted = "Adjusted p-value",
             significance = "Significance") %>%
  fmt_number(columns = c(F.value, p.value, p.adjusted), decimals = 4) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)), 
    locations = cells_body(columns = c("PC", "group2", "F.value", "p.value", "p.adjusted"))) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1), style = "dashed"),
    locations = cells_body(columns = c("group1"))) %>%
  tab_style(
  style = cell_borders(sides = c("top","bottom"), color = "white", weight = px(1)),
  locations = cells_body(columns = "PC")) %>%
  tab_style(
    style = cell_borders(sides = "bottom", color = "darkgray", weight = px(2)),
    locations = cells_body(
      rows = 3,  
      columns = everything()))
  
  


```

#### Plots

```{r}



plot1<- autoplot(PCA.test, data = test.df, colour="Species", loadings=FALSE, loadings.label=FALSE, frame=TRUE, frame.type='norm', label= TRUE)+
  scale_color_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00", "p.mexicana"="#9986A5"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly", "p.mexicana"= "Atlantic molly")) +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00", "p.mexicana"="#9986A5"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly", "p.mexicana"= "Atlantic molly")) + 
   guides(fill = guide_legend(override.aes = list(fill = NA)))+
  ggtitle("PCA Plot of Morphology traits") + theme_classic() 
plot1



plot2<- autoplot(PCA.test, x=2, y=3, data = test.df, colour='Species', loadings=FALSE, loadings.label=FALSE, frame=TRUE, frame.type='norm')+scale_color_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00", "p.mexicana"="#9986A5"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly", "p.mexicana"= "Atlantic molly")) +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00", "p.mexicana"="#9986A5"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly", "p.mexicana"= "Atlantic molly")) + 
   guides(fill = guide_legend(override.aes = list(fill = NA)))+
  ggtitle("PCA Plot of Morphology traits") + theme_classic() 
plot2



```

### Geographic analysis

We are also interested in how the present variation is partitioned across the sampled geographic range. We have two geographic factors to categorize samples: zones (as determined by latitudes) and river basins. While the zone categories allowed us avoid sampling bias, basins may be a better indicator of gene flow. Therfore, we will repeat the above analyses for both zone and basins.  

As our Atlantic molly (*P.mexicana*) samples are from one geographic location, we excluded them from our geographic analyses.

#### Species across Zones

```{r}

geo.df <- test.df[test.df$Species !="p.mexicana", ]

pc1V <- leveneTest(Dim.1~Species*Zone, data=geo.df) # not significant (p=0.223)

pc2V <- leveneTest(Dim.2~Species*Zone, data=geo.df) # significant (p<0.001)

pc3V <- leveneTest(Dim.3~Species*Zone, data=geo.df) # significant (p=0.020)


# Will display results in a table

levene_result <- tibble(
  Dimension = c("PC1", "PC2", "PC3"),
  F_value = c(pc1V$`F value`[1], pc2V$`F value`[1], pc3V$`F value`[1]),
  p_value = c(pc1V$`Pr(>F)`[1], pc2V$`Pr(>F)`[1], pc3V$`Pr(>F)`[1])
) %>%
  mutate(Significance = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01 ~ "**",
    p_value < 0.05 ~ "*",
    TRUE ~ "ns"
  ))

levene_result %>%
  gt() %>%
  cols_label(
    Dimension = "Dimension",
    F_value = "F-value",
    p_value = "p-value",
    Significance = "Significance") %>%
  fmt_number(columns = c("F_value"), decimals = 3) %>%
  fmt(columns = vars(p_value), fns = function(x) {  
    ifelse(x < 0.001, "p < 0.001", formatC(x, format = "f", digits = 3))
  }) 


# Summary of variation for each dimension in each species
  ## Sailfin mollies contain more variation than Amazon mollies for zones 2-4 in PC1, zones 1-4 in PC2, and zone 4 in PC3. 

table_zone <- geo.df %>%
  group_by(Species, Zone) %>%
  summarise(var_dim1 = var(Dim.1, na.rm = TRUE),
            var_dim2 = var(Dim.2, na.rm = TRUE),
            var_dim3 = var(Dim.3, na.rm = TRUE),
            .groups = "drop") %>%
  pivot_wider(names_from = Species, values_from = c(var_dim1, var_dim2, var_dim3)) 

table_zone %>%
  gt()  %>%
  cols_label(var_dim1_p.latipinna = "Sailfin", var_dim1_p.formosa = "Amazon",
             var_dim2_p.latipinna = "Sailfin", var_dim2_p.formosa = "Amazon",
             var_dim3_p.latipinna = "Sailfin", var_dim3_p.formosa = "Amazon") %>%
  tab_spanner(label = "Dimension 1", columns = c("var_dim1_p.latipinna", "var_dim1_p.formosa")) %>%
  tab_spanner(label = "Dimension 2", columns = c("var_dim2_p.latipinna", "var_dim2_p.formosa")) %>%
  tab_spanner(label = "Dimension 3", columns = c("var_dim3_p.latipinna", "var_dim3_p.formosa")) %>%
  fmt_scientific(columns = c("var_dim1_p.latipinna", "var_dim1_p.formosa", "var_dim2_p.latipinna", "var_dim2_p.formosa", "var_dim3_p.latipinna", "var_dim3_p.formosa"), decimals = 2) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)), 
    locations = cells_body(columns = c("Zone", "var_dim1_p.formosa", "var_dim2_p.formosa"))) %>%
  tab_style(style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)),
            locations = cells_column_labels(columns = c("var_dim1_p.formosa", "var_dim2_p.formosa"))) %>% 
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)),
    locations = cells_column_spanners(spanners = c("Dimension 1", "Dimension 2"))) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1), style = "dashed"),
    locations = cells_body(columns = c("var_dim1_p.latipinna", "var_dim2_p.latipinna", "var_dim3_p.latipinna"))
  )

```

##### Plots

```{r}

# Define the zone backgrounds (alternating light gray)
zone_backgrounds <- data.frame(
  Zone = c("Z1", "Z2", "Z3", "Z4"),
  fill_color = c("white", "lightgray", "lightgray", "white")
)

ggplot(geo.df, aes(x = Species, y = Dim.1, fill = Species)) +
  geom_rect(data = zone_backgrounds %>% filter(Zone %in% c("Z2", "Z3")), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Zone) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) +
  xlab("") +
  ylab("PC1") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))

ggplot(geo.df, aes(x = Species, y = Dim.2, fill = Species)) +
  geom_rect(data = zone_backgrounds %>% filter(Zone %in% c("Z2", "Z3")), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Zone) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) + 
  xlab("") +
  ylab("PC2") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))

ggplot(geo.df, aes(x = Species, y = Dim.3, fill = Species)) +
  geom_rect(data = zone_backgrounds %>% filter(Zone %in% c("Z2", "Z3")), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Zone) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) + 
  xlab("") +
  ylab("PC3") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))


```


#### Species across basins

Note that Brazos-Colorado Coastal is only represented by sailfin mollies and not Amazon mollies.

```{r}
pc1V <- leveneTest(Dim.1~Species*Basin, data=geo.df) # not significant (p=0.182)

pc2V <- leveneTest(Dim.2~Species*Basin, data=geo.df) # significant (p<0.001)

pc3V <- leveneTest(Dim.3~Species*Basin, data=geo.df) # significant (p=0.001)


# Will display results in a table

levene_result <- tibble(
  Dimension = c("PC1", "PC2", "PC3"),
  F_value = c(pc1V$`F value`[1], pc2V$`F value`[1], pc3V$`F value`[1]),
  p_value = c(pc1V$`Pr(>F)`[1], pc2V$`Pr(>F)`[1], pc3V$`Pr(>F)`[1])
) %>%
  mutate(Significance = case_when(
    p_value < 0.001 ~ "***",
    p_value < 0.01 ~ "**",
    p_value < 0.05 ~ "*",
    TRUE ~ "ns"
  ))

levene_result %>%
  gt() %>%
  cols_label(
    Dimension = "Dimension",
    F_value = "F-value",
    p_value = "p-value",
    Significance = "Significance") %>%
  fmt_number(columns = c("F_value"), decimals = 3) %>%
  fmt(columns = c("p_value"), fns = function(x) {  
    ifelse(x < 0.001, "p < 0.001", formatC(x, format = "f", digits = 3))
  }) 


# Summary of variation for each dimension in each species
  ## 

table_basin <- geo.df %>%
  group_by(Species, Basin) %>%
  summarise(var_dim1 = var(Dim.1, na.rm = TRUE),
            var_dim2 = var(Dim.2, na.rm = TRUE),
            var_dim3 = var(Dim.3, na.rm = TRUE),
            .groups = "drop") %>%
  pivot_wider(names_from = Species, values_from = c(var_dim1, var_dim2, var_dim3)) 

table_basin %>%
  gt()  %>%
  cols_label(var_dim1_p.latipinna = "Sailfin", var_dim1_p.formosa = "Amazon",
             var_dim2_p.latipinna = "Sailfin", var_dim2_p.formosa = "Amazon",
             var_dim3_p.latipinna = "Sailfin", var_dim3_p.formosa = "Amazon") %>%
  tab_spanner(label = "Dimension 1", columns = c(var_dim1_p.latipinna, var_dim1_p.formosa)) %>%
  tab_spanner(label = "Dimension 2", columns = c(var_dim2_p.latipinna, var_dim2_p.formosa)) %>%
  tab_spanner(label = "Dimension 3", columns = c(var_dim3_p.latipinna, var_dim3_p.formosa)) %>%
  fmt_scientific(columns = c("var_dim1_p.latipinna", "var_dim1_p.formosa","var_dim2_p.latipinna", "var_dim2_p.formosa", "var_dim3_p.latipinna", "var_dim3_p.formosa"), decimals = 2) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)), 
    locations = cells_body(columns = c(Basin, var_dim1_p.formosa, var_dim2_p.formosa))) %>%
  tab_style(style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)),
            locations = cells_column_labels(columns = c("var_dim1_p.formosa", "var_dim2_p.formosa"))) %>% 
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1.5)),
    locations = cells_column_spanners(spanners = c("Dimension 1", "Dimension 2"))) %>%
  tab_style(
    style = cell_borders(sides = "right", color = "lightgray", weight = px(1), style = "dashed"),
    locations = cells_body(columns = c("var_dim1_p.latipinna", "var_dim2_p.latipinna", "var_dim3_p.latipinna"))
  )


```

##### Plots

```{r}

# Define alternating background colors for basins
basin_backgrounds <- data.frame(
  Basin = factor(c("Nueces-Rio Grande Costal", "Rio Grande", "Brazos-Colorado Costal", "Panuco", "San Fernando-Soto la Marina")),
  fill_color = rep(c("white", "lightgray"), length.out = 5)  # Alternating colors
)



ggplot(geo.df, aes(x = Species, y = Dim.1, fill = Species)) +
  geom_rect(data = basin_backgrounds %>% filter(fill_color == "lightgray"), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Basin) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) + xlab("") +
  ylab("PC1") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))

ggplot(geo.df, aes(x = Species, y = Dim.2, fill = Species)) +
  geom_rect(data = basin_backgrounds %>% filter(fill_color == "lightgray"), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Basin) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) + xlab("") +
  ylab("PC2") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))

ggplot(geo.df, aes(x = Species, y = Dim.3, fill = Species)) +
  geom_rect(data = basin_backgrounds %>% filter(fill_color == "lightgray"), aes(xmin = -Inf, xmax = Inf, ymin = -Inf, ymax = Inf), fill="lightgray", alpha = 0.3, inherit.aes = FALSE) + 
  geom_boxplot() +
  facet_wrap(~ Basin) +
  theme_classic() + theme(
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank()
  ) + xlab("") +
  ylab("PC3") +
  scale_fill_manual(name="Species",
                    values = c("p.latipinna"="#78B7C5", "p.formosa"="#E1AF00"),
                    labels= c("p.latipinna"="Sailfin molly", "p.formosa"= "Amazon molly"))


```



## Summary of variation analyses

As expected, we see that Amazons are intermediate to both parents in overall shape. This is most evident in PC1, but in PC 2 & 3, there is a lot of overlap between the species. This is likely due to PC 2 & 3 explaining much less variation, so there is less that distinguishes the groups. 

When we perform our Levene's test, we see that there is no significant difference in variation among the species for PC1, but there is a significant difference for PC2 (p=0.0006) and PC3 (p=0.0135). Landmarks 3 (x-coor), 9 (x-coor), and 10 (y-coor) all load heavily on PC2, which correspond to dorsal position and body depth. We see that sailfins contain significantly more variation than Amazons and more variation (NS) than Atlantics for PC2 (note: PC1 included in table but only PC2 had significant difference). For PC3, it is only landmark 2 that loads heavily, which could correspond to head depth. Here we see that Amazons are significantly more variable than sailfin mollies, and more variable (NS) than Atlantics. 

It is good to remember though, that while PC 2 & 3 shows significant differences in PC shape variation, and interesting results regarding Amazons varying more than parentals, these PCs explain much less variation than PC1, which shows no significant difference. 

***

Previous results are echoed in the geographic analysis, regardless of whether 'zones' or 'basins' was selected as the geographic characteristic. PC1 was not different between species across zones (p=0.223) or basins (p=0.182). PC2 and PC3 were significantly different between species across both zones (PC2: p<0.001; PC3: p=0.020) and basins (PC2: p<0.001; PC3: p=0.001). For zones, sailfin mollies contained more variation than Amazons in all zones for PC2 but only in zone 4 in PC3. For basins, sailfins contained more variation than Amazons in all river basins for PC2 and in 2 of the 4 river basins in PC3 (note: one river basin only contained sailfins). 


***
***
***

# PART 2: methodology analysis

The following analyses will compare the ACCURACY/PRECISION? of digital versus manual measurements. 

## Data 

Manual measurement data were collected for a separate study (PAPER?). Data include # merestic and # metric traits. In order to compare to the digital measurements, only # metric traits from the manual measured data were included. 

Digital morpohometric data consisted of # landmarks and # semi-landmarks. To obtain comparable distance measurements, we calculated the euclidean distance between the landmark coordinates that best matched the features used in manual measurement; see table below for associated landmarks and manual measurements. Digital distance is originally formatted in pixels so using the scale factor for each image in the original TPS files, we converted the distance into millimeters. 

For more details on data inclusion and distance calculation, please see Methods in the associated paper. 

TABLE WITH LANDMARKS AND HAND MEASUREMENT TYPE


To get digital distances:
The TPS coordinates were in a long format, and I thought it would be easiest to locate the values needed to insert into the euclidean distance formula with a wide format. So, I first cleaned up the original TPS file--I removed all curve data, and unnecessary rows (ie. LM=16, image=) to be left with a column of IDs, a column of landmark labels, and two columns for the coordinates.

Importing that into R, I then used the wider fxn to create one column for IDs, 16 columns for the X coordinates of all the landmarks, and 16 columns for all the y coordinates of all the landmarks (originally wanted it to be a coordinates column, so there would be two rows for each specimen to minimize column numbers, but whatever, this works). I separated this into two dataframes, one with just the X coords and one with just the Y, that way it would be easier to call. 

I calculated the euclidean distance (formula: sqrt(sq(X$LM2-X$LM1)+sq(Y$LM2-Y$LM1))) for most of the same measurements (only missing total length, and head width, as this was not possible in the digital photos). For head depth, wasn't sure if 2-> 11 or 2->12 was closer to what I measured by hand; same for body depth, wasn't sure if it was 3->10 or 3->11. I included both. 

finished all of the calculations and added the values into a dataframe with the IDs from the original tps file. Exported it to excel

Once in excel, I realized that the values I had were in pixels rather than mm, so I needed to find a way to convert in order to compare to the hand measurements. I found out that the scale factor (included in the original tps file) is cm/pixel, so I added this to the excel, and multiplied it to each value to get the cm, then by 10 to get mm. 

Below is for reference only. For details on how I formated, see original geomorph rmd.


HL.dig <- sqrt(((x$X.COR_LM2 -x$X.COR_LM1)^2 + (y$Y.COR_LM2-y$Y.COR_LM1)^2))
SL.dig <- sqrt(((x$X.COR_LM6 -x$X.COR_LM1)^2 + (y$Y.COR_LM6-y$Y.COR_LM1)^2))
PreDL.dig <- sqrt(((x$X.COR_LM3 -x$X.COR_LM1)^2 + (y$Y.COR_LM3-y$Y.COR_LM1)^2))
DbL.dig <- sqrt(((x$X.COR_LM4 -x$X.COR_LM3)^2 + (y$Y.COR_LM4-y$Y.COR_LM3)^2))
CPD.dig <- sqrt(((x$X.COR_LM7 -x$X.COR_LM5)^2 + (y$Y.COR_LM7-y$Y.COR_LM5)^2))
HD1.dig <- sqrt(((x$X.COR_LM11 -x$X.COR_LM2)^2 + (y$Y.COR_LM11-y$Y.COR_LM2)^2))
HD2.dig <- sqrt(((x$X.COR_LM12 -x$X.COR_LM2)^2 + (y$Y.COR_LM12-y$Y.COR_LM2)^2))
CPL.dig <- sqrt(((x$X.COR_LM8 -x$X.COR_LM6)^2 + (y$Y.COR_LM8-y$Y.COR_LM6)^2))
BD1.dig <- sqrt(((x$X.COR_LM3 -x$X.COR_LM10)^2 + (y$Y.COR_LM3-y$Y.COR_LM10)^2))
BD2.dig <- sqrt(((x$X.COR_LM3 -x$X.COR_LM11)^2 + (y$Y.COR_LM3-y$Y.COR_LM11)^2))
SnL.dig <- sqrt(((x$X.COR_LM15 -x$X.COR_LM1)^2 + (y$Y.COR_LM15-y$Y.COR_LM1)^2))
OL.dig <- sqrt(((x$X.COR_LM16 -x$X.COR_LM15)^2 + (y$Y.COR_LM16-y$Y.COR_LM15)^2))


***
***
***

### Read in Data

```{r}


raw <- curl("https://raw.githubusercontent.com/allisondavis/morphology_analysis/refs/heads/master/comparison_data2.csv")

raw <- read.csv(raw, header = TRUE, sep = ",", stringsAsFactors = TRUE)

#AD20-084 is missing all manual values, so I will remove to avoid issues with NAs
raw<- raw[raw$ID !="AD20-082", ]

```

### Normality check

We used Shapiro-Wilk tests, histograms, and QQ plots to determine what traits were normal, and performed transformations as needed. The original raw data set was separated into the two factors of interest: digital and manual measurements.


```{r}


digital <- raw %>%
  select(ID, SPP, ends_with(".dig"))

manual <- raw %>%
  select(ID, SPP, ends_with(".man"))

```

#### Digital 

All but OL fail the Shapiro-Wilk test with a slight skew/deviation to the right.

```{r}

##### Shapiro-Wilk test #####
shapiro.test(digital$SL)

shapiro.test(digital$BD1)

shapiro.test(digital$BD2)

shapiro.test(digital$CPD)

shapiro.test(digital$CPL)

shapiro.test(digital$PreDL)

shapiro.test(digital$DbL)

shapiro.test(digital$HL)

shapiro.test(digital$HD1)

shapiro.test(digital$HD2)

shapiro.test(digital$SnL)

shapiro.test(digital$OL)

##### Histograms #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

hist(digital$SL, breaks=30)

hist(digital$BD1, breaks=30)

hist(digital$BD2, breaks=30)

hist(digital$CPD, breaks=30)

hist(digital$CPL, breaks=30)

hist(digital$PreDL, breaks=30)

hist(digital$DbL, breaks=30)

hist(digital$HL, breaks=30)

hist(digital$HD1, breaks=30)

hist(digital$HD2, breaks=30)

hist(digital$SnL, breaks=30)

hist(digital$OL, breaks=30)


##### QQ plots #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

qqnorm(digital$SL)
qqline(digital$SL)

qqnorm(digital$BD1)
qqline(digital$BD1)

qqnorm(digital$BD2)
qqline(digital$BD2)

qqnorm(digital$CPD)
qqline(digital$CPD)

qqnorm(digital$CPL)
qqline(digital$CPL)

qqnorm(digital$PreDL)
qqline(digital$PreDL)

qqnorm(digital$DbL)
qqline(digital$DbL)

qqnorm(digital$HL)
qqline(digital$HL)

qqnorm(digital$HD1)
qqline(digital$HD1)

qqnorm(digital$HD2)
qqline(digital$HD2)

qqnorm(digital$SnL)
qqline(digital$SnL)

qqnorm(digital$OL)
qqline(digital$OL)



```


#### Manual

All fail the SW test, with a slight skew/deviation to the right. 

```{r}

##### Shapiro-Wilk test #####
shapiro.test(manual$SL)

shapiro.test(manual$BD1)

shapiro.test(manual$CPD)

shapiro.test(manual$CPL)

shapiro.test(manual$PreDL)

shapiro.test(manual$DbL)

shapiro.test(manual$HL)

shapiro.test(manual$HD1)

shapiro.test(manual$SnL)

shapiro.test(manual$OL)

##### Histograms #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

hist(manual$SL, breaks=30)

hist(manual$BD1, breaks=30)

hist(manual$CPD, breaks=30)

hist(manual$CPL, breaks=30)

hist(manual$PreDL, breaks=30)

hist(manual$DbL, breaks=30)

hist(manual$HL, breaks=30)

hist(manual$HD1, breaks=30)

hist(manual$SnL, breaks=30)

hist(manual$OL, breaks=30)


##### QQ plots #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

qqnorm(manual$SL)
qqline(manual$SL)

qqnorm(manual$BD1)
qqline(manual$BD1)

qqnorm(manual$CPD)
qqline(manual$CPD)

qqnorm(manual$CPL)
qqline(manual$CPL)

qqnorm(manual$PreDL)
qqline(manual$PreDL)

qqnorm(manual$DbL)
qqline(manual$DbL)

qqnorm(manual$HL)
qqline(manual$HL)

qqnorm(manual$HD1)
qqline(manual$HD1)

qqnorm(manual$SnL)
qqline(manual$SnL)

qqnorm(manual$OL)
qqline(manual$OL)



```

#### Log transform & recheck

While some values are still significant, log transformations vastly improve normality (eg p=2e-16 to p=0.002). The histograms and QQ plots look pretty damn normal, so I will stick with log transformed values. 

Log transformed data sets

```{r}
dig_trans <- digital
dig_trans[, c(3:14)] <- log(dig_trans[, c(3:14)])

man_trans <- manual
man_trans[, c(3:12)] <- log(man_trans[, c(3:12)])


```

##### Digital

OL was the only one that was normal in raw check, but since it was not normal in manual, and I want to compare dig to man, I will transform the OL here too (don't want to compare raw to transformed measurements).

```{r}
##### Shapiro-Wilk test #####
shapiro.test(dig_trans$SL)

shapiro.test(dig_trans$BD1)

shapiro.test(dig_trans$BD2)

shapiro.test(dig_trans$CPD)

shapiro.test(dig_trans$CPL)

shapiro.test(dig_trans$PreDL)

shapiro.test(dig_trans$DbL)

shapiro.test(dig_trans$HL)

shapiro.test(dig_trans$HD1)

shapiro.test(dig_trans$HD2)

shapiro.test(dig_trans$SnL)

shapiro.test(dig_trans$OL)

##### Histograms #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

hist(dig_trans$SL, breaks=30)

hist(dig_trans$BD1, breaks=30)

hist(dig_trans$BD2, breaks=30)

hist(dig_trans$CPD, breaks=30)

hist(dig_trans$CPL, breaks=30)

hist(dig_trans$PreDL, breaks=30)

hist(dig_trans$DbL, breaks=30)

hist(dig_trans$HL, breaks=30)

hist(dig_trans$HD1, breaks=30)

hist(dig_trans$HD2, breaks=30)

hist(dig_trans$SnL, breaks=30)

hist(dig_trans$OL, breaks=30)


##### QQ plots #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

qqnorm(dig_trans$SL)
qqline(dig_trans$SL)

qqnorm(dig_trans$BD1)
qqline(dig_trans$BD1)

qqnorm(dig_trans$BD2)
qqline(dig_trans$BD2)

qqnorm(dig_trans$CPD)
qqline(dig_trans$CPD)

qqnorm(dig_trans$CPL)
qqline(dig_trans$CPL)

qqnorm(dig_trans$PreDL)
qqline(dig_trans$PreDL)

qqnorm(dig_trans$DbL)
qqline(dig_trans$DbL)

qqnorm(dig_trans$HL)
qqline(dig_trans$HL)

qqnorm(dig_trans$HD1)
qqline(dig_trans$HD1)

qqnorm(dig_trans$HD2)
qqline(dig_trans$HD2)

qqnorm(dig_trans$SnL)
qqline(dig_trans$SnL)

qqnorm(dig_trans$OL)
qqline(dig_trans$OL)



```


##### Manual

```{r}
##### Shapiro-Wilk test #####
shapiro.test(man_trans$SL)

shapiro.test(man_trans$BD1)

shapiro.test(man_trans$CPD)

shapiro.test(man_trans$CPL)

shapiro.test(man_trans$PreDL)

shapiro.test(man_trans$DbL)

shapiro.test(man_trans$HL)

shapiro.test(man_trans$HD1)

shapiro.test(man_trans$SnL)

shapiro.test(man_trans$OL)

##### Histograms #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

hist(man_trans$SL, breaks=30)

hist(man_trans$BD1, breaks=30)

hist(man_trans$CPD, breaks=30)

hist(man_trans$CPL, breaks=30)

hist(man_trans$PreDL, breaks=30)

hist(man_trans$DbL, breaks=30)

hist(man_trans$HL, breaks=30)

hist(man_trans$HD1, breaks=30)

hist(man_trans$SnL, breaks=30)

hist(man_trans$OL, breaks=30)


##### QQ plots #####

par(mfcol=c(2,2), oma = c(0,0,2,0))

qqnorm(man_trans$SL)
qqline(man_trans$SL)

qqnorm(man_trans$BD1)
qqline(man_trans$BD1)

qqnorm(man_trans$CPD)
qqline(man_trans$CPD)

qqnorm(man_trans$CPL)
qqline(man_trans$CPL)

qqnorm(man_trans$PreDL)
qqline(man_trans$PreDL)

qqnorm(man_trans$DbL)
qqline(man_trans$DbL)

qqnorm(man_trans$HL)
qqline(man_trans$HL)

qqnorm(man_trans$HD1)
qqline(man_trans$HD1)

qqnorm(man_trans$SnL)
qqline(man_trans$SnL)

qqnorm(man_trans$OL)
qqline(man_trans$OL)

```

### Formatting 

I will perform 3 different analyses: Bland-Altman, MANOVA and PCA. These vary in whether they need long or wide formats. Also, the raw data contains columns that are not needed for these analyses (eg location or photo date) so I will remove those to leave just the species, tag ID, and measurements.

Additionally, since we have two measurements for BD and HD, we will create two datasets: one with BD1 and HD1, and another with BD2 and HD2 (this applies to digital only, as manual only has one measurement for each). Once we run BA plots, we can determine which of these measurements is best to continue analysis with.


**Long format**

```{r}


#log transform entire data set

raw2 <- raw
raw2[, c(3:24)] <- log(raw2[, c(3:24)])

# this will create a data frame with species, ID, characteristic, method and value
df_long <- raw2 %>%
  pivot_longer(
    cols = ends_with(".dig") | ends_with(".man"),
    names_to = c("characteristic", "method"),
    names_sep = "\\.",
    values_to = "value"
  )

# method and characteristic are initially a character; need to be a factor
df_long$method <- as.factor(df_long$method)
df_long$characteristic <- as.factor(df_long$characteristic)


#create data frames that only have one measurement for BD and HD

## BD1 and HD1 for both digital and manual measurements 
df_long2 <- df_long[-grep("BD2", df_long$characteristic),]
df_long2 <- df_long2[-grep("HD2", df_long2$characteristic),]#only contains BD1 & HD1

## BD1/HD1 for manual (since they only have one) and BD2/HD2 for digital
df_long3 <- df_long %>%
    filter(
    # Keep everything for Hand measurements
    method == "man" |
    # Keep all digital measurements except BD1 and HD1
    !(method == "dig" & characteristic %in% c("BD1", "HD1"))
  )

#to ensure comparisons between BD2 and BD1 in this new data frame, will combine characteristic names to just BD or HD

df_long3<- df_long3 %>%
  mutate(
    characteristic = case_when(
      characteristic %in% c("BD1", "BD2") ~ "BD",
      characteristic %in% c("HD1", "HD2") ~ "HD",
      TRUE ~ characteristic  # Leave other characteristics unchanged
    )
  )


```


**Wide format**

```{r}
df_wide <- df_long2 %>%
  pivot_wider(
    names_from = method,
    values_from = value
  )


df_wide2 <- df_long3 %>%
  pivot_wider(
    names_from = method,
    values_from = value
  )

```



## Bland-Altman Plot

Used to assess agreement between two measurement methods.

### BD/HD plots

We're first interested in how BD1, HD1, BD2, and HD2 compare, so let's isolate those.


```{r}

data_BD1 <- df_wide %>%
  filter(characteristic == "BD1")
data_BD1 <- data_BD1 %>%
  mutate(
    average = (dig + man) / 2,
    difference = dig - man
  )

data_HD1 <- df_wide %>%
  filter(characteristic == "HD1")
data_HD1 <- data_HD1 %>%
  mutate(
    average = (dig + man) / 2,
    difference = dig - man
  )


data_BD2 <- df_wide2 %>%
  filter(characteristic == "BD")
data_BD2 <- data_BD2 %>%
  mutate(
    average = (dig + man) / 2,
    difference = dig - man
  )


data_HD2 <- df_wide2 %>%
  filter(characteristic == "HD")
data_HD2 <- data_HD2 %>%
  mutate(
    average = (dig + man) / 2,
    difference = dig - man
  )


ba_BD1 <- ggplot(data_BD1, aes(x = average, y = difference, color=SPP)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(data_BD1$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(data_BD1$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(data_BD1$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "BD1",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()


ba_HD1 <- ggplot(data_HD1, aes(x = average, y = difference, color=SPP)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(data_HD1$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(data_HD1$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(data_HD1$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "HD1",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()

ba_BD2 <- ggplot(data_BD2, aes(x = average, y = difference, color=SPP)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(data_BD2$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(data_BD2$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(data_BD2$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "BD2",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()


ba_HD2 <- ggplot(data_HD2, aes(x = average, y = difference, color=SPP)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(data_HD2$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(data_HD2$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(data_HD2$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "HD2",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()



grid.arrange(ba_BD1, ba_BD2, ba_HD1, ba_HD2)






```

We see that BD1 has less scatter, less outside LOA and a smaller bias compared to BD2 (0.12 vs 0.36). In addition, BD2's LOA don't include 0, so BD1 is more appropriate to use. In contrast, HD1, while it has less scatter with fewer points outside the LOA, it has a bias further away from 0 compared to HD2 (which has slightly more scatter and more points outside LOA), so HD2 is more appropriate to use (0.06 vs -0.008). 

I will therefore create a final dataset with BD1 and HD2 for all subsequent analyses. 

### BA plots

#### Final data frame

```{r, echo=FALSE}
###create final dataset
df_long_fin <- df_long[-grep("BD2", df_long$characteristic),] #removes BD2

df_long_fin <- df_long_fin %>%
    filter(
    # Keep everything for Hand measurements
    method == "man" |
    # Keep all digital measurements except HD1
    !(method == "dig" & characteristic %in% c("HD1"))
  )

df_long_fin<- df_long_fin %>%
  mutate(
    characteristic = case_when(
      characteristic %in% c("BD1", "BD2") ~ "BD",
      characteristic %in% c("HD1", "HD2") ~ "HD",
      TRUE ~ characteristic  # Leave other characteristics unchanged
    )
  )

df_wide_fin <- df_long_fin %>%
  pivot_wider(
    names_from = method,
    values_from = value
  )


```

#### All traits

We see major clusters on the BA plot for all the data. When colored by species, we see that this does not differentiate the clusters, so it is not a species difference we're seeing. When colored by characteristic, we see this nicely corresponds to the clustering. This is due to differences in range of the measurements we used (eg standard length can range from 14-40mm but snout length ranges from 1-3mm). 

```{r}

df_ba_fin <- df_wide_fin %>%
  mutate(
    average = (dig + man) / 2,
    difference = dig - man
  )

ba_full_fin <- ggplot(df_ba_fin, aes(x = average, y = difference)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(df_ba_fin$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "Bland-Altman Plots for All Characteristics",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()

ba_full_fin


##### Species

ba_full_SPP_fin <- ggplot(df_ba_fin, aes(x = average, y = difference, color=SPP)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(df_ba_fin$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "Bland-Altman Plots for All Characteristics",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()

ba_full_SPP_fin


##### Characteristics

ba_full_CR_fin <- ggplot(df_ba_fin, aes(x = average, y = difference, color=characteristic)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(df_ba_fin$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "Bland-Altman Plots for All Characteristics",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  theme_minimal()

ba_full_CR_fin

```


#### By trait

```{r}
ba_by_char_fin <- ggplot(df_ba_fin, aes(x = average, y = difference)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "solid", color = "black") +
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE), color = "red", linetype = "dashed") +  # Mean line
  geom_hline(yintercept = mean(df_ba_fin$difference, na.rm = TRUE) + c(-1.96, 1.96) * sd(df_ba_fin$difference, na.rm = TRUE),
             color = "blue", linetype = "dashed") +  # Limits of agreement
  labs(title = "Bland-Altman Plots for All Characteristics",
       x = "Average of Digital and Hand Measurements",
       y = "Difference (Digital - Hand)") +
  facet_wrap(~ characteristic, scales = "free") +
  theme_minimal()

ba_by_char_fin

```


### BA Stats

We can extract the important information (bias, LOAs, confidence intervals, and p-value after a one-sided t-test to see if bias is different from 0) using the blandr package. Contacted the author, and there may be a way to loop this, but for now will run on individual stats. 

```{r}



### Whole dataset

(bar_full <- blandr.statistics(df_wide_fin$dig, df_wide_fin$man))

### By characteristic

df_SL <- df_wide_fin %>%
  filter(characteristic == "SL")
(bar_SL <- blandr.statistics(df_SL$dig, df_SL$man))

df_BD <- df_wide_fin %>%
  filter(characteristic == "BD")
(bar_BD <- blandr.statistics(df_BD$dig, df_BD$man))

df_CPD <- df_wide_fin %>%
  filter(characteristic == "CPD")
(bar_CPD <- blandr.statistics(df_CPD$dig, df_CPD$man))

df_CPL <- df_wide_fin %>%
  filter(characteristic == "CPL")
(bar_CPL <- blandr.statistics(df_CPL$dig, df_CPL$man))

df_PreDL <- df_wide_fin %>%
  filter(characteristic == "PreDL")
(bar_PreDL <- blandr.statistics(df_PreDL$dig, df_PreDL$man))

df_DbL <- df_wide_fin %>%
  filter(characteristic == "DbL")
(bar_DbL <- blandr.statistics(df_DbL$dig, df_DbL$man))

df_HL <- df_wide_fin %>%
  filter(characteristic == "HL")
(bar_HL <- blandr.statistics(df_HL$dig, df_HL$man))

df_HD <- df_wide_fin %>%
  filter(characteristic == "HD")
(bar_HD <- blandr.statistics(df_HD$dig, df_HD$man))

df_SnL <- df_wide_fin %>%
  filter(characteristic == "SnL")
(bar_SnL <- blandr.statistics(df_SnL$dig, df_SnL$man))

df_OL <- df_wide_fin %>%
  filter(characteristic == "OL")
(bar_OL <- blandr.statistics(df_OL$dig, df_OL$man))



```


While p-values for just about all of the characteristics are significant, we see that the bias itself is incredibly close to zero. The significant t-test may be a result of very little deviation, so any deviation is flagged as significant, but is not methodilogically relevent (ie there is not actual difference in methods).


## MANOVA

We will run a repeated measures MANOVA on our data to corroborate our Bland-Altman results. We will follow up our MANOVA with an effect size calculation to see if any statistical significance is methodilogically relevent. 

### Data frame

First, need a data frame with two rows per individual (one for digital and one for manual), plus 10 columns corresponding to each characteristic. Will create new long/wide formats since the ones above don't have separate columns for the characteristics. 

```{r}


raw3 <- raw2 %>%
  rename(HD.dig = HD2.dig, HD.man = HD1.man)

raw3<- raw3[-5] #removes BD2
raw3<- raw3[-10] #removes HD1 for digital

df_long_ex <- raw3 %>%
  pivot_longer(cols = -c(ID, SPP), 
               names_to = "Measurement", 
               values_to = "Value") %>%
  mutate(Method = ifelse(str_detect(Measurement, ".dig"), "Digital", "Manual"),
         Character = str_remove_all(Measurement, ".dig|.man")) %>%
  select(ID, Method, Character, Value)

df_wide_ex <- df_long_ex %>%
  pivot_wider(names_from = Character, values_from = Value)


```

### Results

Similar to our BA stats, we see a significant but not practical difference between methods. The MANOVA is statistically significant (p<0.001) but have a small effect size (0.0267). This means that method only explains 2.67% of the variance in our data. 

```{r}

manova_mod <- manova(cbind(SL, BD1, CPD, CPL, PreDL, DbL, HL, HD, SnL, OL) ~ Method + Error(ID/Method), data=df_wide_ex)

summary(manova_mod, test= "Pillai")

# resutls from summary
pillai_method <- 0.90343
num_df_method <- 10
den_df_method <- 329

# Calculate partial eta-squared for Method
eta_squared_method <- pillai_method / (pillai_method + (den_df_method / num_df_method))

# Print the result
cat("Partial Eta-Squared (Method):", eta_squared_method, "\n")


```


## PCA

In this analysis, I will compare the principle components after centering and scaling the data. A PCA analysis will help us determine which methodology influence the variation in our data the most without worrying about differences in scales/measurements.


### Data sets

In order to create ellipses around each method, we need to create a data frame where we have a method column. 

Let's create the data sets

```{r}



z.scores <- raw3

z.scores[, c(3:22)] <- scale(z.scores[, 3:22], center = TRUE, scale = TRUE)

z.long <- z.scores %>%
  pivot_longer(cols = -c(ID, SPP), 
               names_to = "Measurement", 
               values_to = "Value") %>%
  mutate(Method = ifelse(str_detect(Measurement, ".dig"), "Digital", "Manual"),
         Character = str_remove_all(Measurement, ".dig|.man")) %>%
  select(ID, Method, Character, Value)

z.wide <- z.long %>%
  pivot_wider(names_from = Character, values_from = Value)


```

### PCAs

Now let's run the individual PCAs

#### Digital PCA

```{r}


PCA_z <- prcomp(z.wide[, 3:12])

summary(PCA_z)

(loadings_z <- PCA_z$rotation[, 1:5])

(z.eig.val <- get_eigenvalue(PCA_z))

z.ind <- get_pca_ind(PCA_z)

z.wide <- cbind(z.wide, z.ind$coord[,1:3])


z.sorted.loadings.1 <- loadings_z[order(loadings_z[, 1]), 1]
z.myTitle <- "Loadings Plot for PC1" 
z.myXlab  <- "Variable Loadings"
dotchart(z.sorted.loadings.1, main=z.myTitle, xlab=z.myXlab, cex=0.5, col="blue")

z.sorted.loadings.2 <- loadings_z[order(loadings_z[, 2]), 2]
z.myTitle <- "Loadings Plot for PC2" 
z.myXlab  <- "Variable Loadings"
dotchart(z.sorted.loadings.2, main=z.myTitle, xlab=z.myXlab, cex=0.5, col="blue")

z.sorted.loadings.3 <- loadings_z[order(loadings_z[, 3]), 3]
z.myTitle <- "Loadings Plot for PC3" 
z.myXlab  <- "Variable Loadings"
dotchart(z.sorted.loadings.3, main=z.myTitle, xlab=z.myXlab, cex=0.5, col="blue")

```



### Comparisons

Now let's do the comparisons

#### T-tests

No significant differences.

```{r}
zw.dig <- z.wide %>%
  filter(Method == "Digital")

zw.man <- z.wide %>%
  filter(Method == "Manual")


(pc1 <- t.test(zw.dig$Dim.1, zw.man$Dim.1, paired= TRUE, alternative = "two.sided"))

(pc2 <- t.test(zw.dig$Dim.2, zw.man$Dim.2, paired= TRUE, alternative = "two.sided"))

(pc3 <- t.test(zw.dig$Dim.3, zw.man$Dim.3, paired= TRUE, alternative = "two.sided"))




```

#### Levene's tests

No significant differences. 

```{r}

(pc1V <- leveneTest(Dim.1~Method, data=z.wide))
(pc1V <- leveneTest(Dim.2~Method, data=z.wide))
(pc1V <- leveneTest(Dim.3~Method, data=z.wide))



```

### Plots


#### PCA 1v2


```{r}

digVman <- autoplot(PCA_z, data = z.wide, colour="Method", loadings=FALSE, loadings.label=FALSE, frame=TRUE, frame.type='norm')+scale_color_manual(values=c("#E1AF00","#78B7C5"))+ scale_fill_manual(values=c("#E1AF00","#78B7C5"))+ ggtitle("PCA Plot of Methods") + theme_classic() 

digVman

```


#### PCA 2v3


```{r}
digVman2 <- autoplot(PCA_z, data = z.wide, colour="Method", loadings=FALSE, loadings.label=FALSE, frame=TRUE, frame.type='norm')+scale_color_manual(values=c("#E1AF00","#78B7C5"))+ scale_fill_manual(values=c("#E1AF00","#78B7C5"))+ ggtitle("PCA Plot of Methods") + theme_classic() 
```



## Overall Results

Our main goal with this R analysis was to compare the precision of manual and digital measurements. 

We first use Bland-Altman plots which compares how closely two methods are to each other. We see that for each characteristic and for our combined data, the bias is close to zero (range: -0.1 to 0.1) with LOAs that include zero, indicating little to no difference between the two methods. Note that for biases greater than zero, this indicates digital measurements were on average larger, whereas biases less than zero indicate larger manual measurements. While the statistical tests for the Bland-Altman plots (one-sided t-test to see if bias is different than zero) indicate a significant difference between the methods, we feel that the biases and LOAs themselves indicate no practical difference. The significant results are likely due to small deviations in an otherwise consistent data set that will statistically indicate a difference, but these differences in reality are minuscule. 

Since these characteristics are no independent of each other, a more robust statistical test (than the t-tests on individual characteristics) is a repeated measures MANOVA. This allowed us to compare the manual and digital methods while treating all the characteristics as related variables. Similar to our Bland-Altman results, we see a significant difference (p<0.001). However, when we calculate the effect size, we see a small effect size (0.0267). This again illustrates that while there is a statistical difference between the two methods, this difference is not practical. Only 2.67% of the variance in our data is explained by the difference in measurement method. 

Lastly, to characterize the overall shape difference and compare variation among the methods, we performed a principal component analysis. Both paired t-tests and Levene's tests on the PC scores showed no significant difference between the two methods, corroborating our interpretation of the practical results from our previous analyses.


Overall, we conclude there is no practical difference between manual and digital measurements. 




